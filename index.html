<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title> structure.js </title>
  <script type="text/javascript" src="coffeescript.min.js"></script>
  <script type="text/javascript" src="glpk.min.js"></script>
  <script type="text/javascript" src="d3.v2.min.js"></script>
  <link href='http://fonts.googleapis.com/css?family=Alegreya+Sans+SC:100,300,400,500,700,800,900,100italic,300italic,400italic,500italic,700italic,800italic,900italic|Alegreya+Sans:100,300,400,500,700,800,900,100italic,300italic,400italic,500italic,700italic,800italic,900italic' rel='stylesheet' type='text/css'>


  <style type="text/css">

  body {
      font-family: "Alegreya Sans";
      overflow-x: hidden;
      overflow-y: hidden;
      background-color: #d4d4d4;
      color: #3d3130;
      line-height: 1.4;
  }

#controls{
    position: fixed;
    bottom: 5;
    left: 5;
}

#title {
    position: fixed;
    right: 15;
    bottom: -30;
    line-height: 0.5;
    font-size: 20em;
    font-family: "Alegreya Sans SC";
    font-style: italic;
    font-weight: 900;
    text-align: right;
    color: white;
    opacity: 0.3;
    z-index: -1;
}

.node {
  fill: #3d3130;
  cursor: move;
}

.node_selected {
  fill: #807ec7;
}

.drag_line {
  stroke: #9c7b70;
  pointer-events: none;
}

.drag_line_hidden {
  stroke: #9c7b70;
  stroke-width: 0;
  pointer-events: none;
}

.link {
  stroke: #9c7b70;
  cursor: move;
}

.compression {
    stroke: #f15a5e;
}

.tension {
    stroke: #2eabe2;
}

.link_selected {
  stroke: #807ec7;
}

.force {
  stroke: #3d3130;
}

.grad {
  stroke: #807ec7;
}

rect {
    cursor: crosshair;
}
  </style>
  <script type="text/coffeescript" src="structure.tacit.coffee"></script>
<script type="text/coffeescript">
sum = (o) -> o.reduce((a,b) -> a+b)
dist = (a, b) ->
    Math.sqrt(sum(if b then Math.pow(ai - b[i], 2) else Math.pow(ai, 2) for ai, i in a))
isempty = (o) -> Object.keys(o).length is 0
print = (o) -> console.log(o)
abs = (a) -> Math.abs(a)

s = new tacit.Structure
new s.Beam({x: 0, y: 0}, {x: 1, y: 1})
new s.Beam({x: 1, y: 1}, {x: 2, y: 0})
s.nodeList[i].fixed[dim] = true for i in [0,2] for dim in ["x", "y"]
s.nodeList[1].force.y = -1

showgrad = document.getElementById("grad")
showforce = document.getElementById("force")
move = document.getElementById("move")
showzero = document.getElementById("showzero")

[width, height] = [window.innerWidth, window.innerHeight]
vis = drag_line = null
scale = 1
rescale = ->
    scale = d3.event.scale
    vis.attr("transform",
             "translate(#{d3.event.translate}) scale(#{scale})")
    repositionzoom()
zoomer = d3.behavior.zoom().on("zoom", rescale)

# event handlers
selected_node = selected_link = mousedown_link = mousedown_node = mouseup_node = null
resetMouseVars = -> mousedown_node = mouseup_node = mousedown_link = null

mousedown = -> if not mousedown_node and not mousedown_link # if nothing is selected
    vis.call(d3.behavior.zoom().on("zoom"), rescale)        # allow panning

mousemove = -> if mousedown_node
    if move.checked
        mousedown_node.x =  d3.svg.mouse(this)[0]
        mousedown_node.y =  d3.svg.mouse(this)[1]
        beam.update() for beam in mousedown_node.sourced.concat(mousedown_node.targeted)
        repositionfast()
    else
        drag_line
            .attr("x1", mousedown_node.x).attr("x2", d3.svg.mouse(this)[0])
            .attr("y1", mousedown_node.y).attr("y2", d3.svg.mouse(this)[1])

mouseup = ->
    if mousedown_node
        # hide drag line
        drag_line.attr("class", "drag_line_hidden")
        if not mouseup_node
            # add node
            point = d3.mouse(this)
            node_ = new s.Node({x: point[0], y: point[1]})
            node_.force.y = -1
            # select new node
            selected_node = node_
            selected_link = null
            # add link to mousedown node
            beam_ = new s.Beam(mousedown_node.id, node_.id)
        redraw()
    # clear mouse event vars
    resetMouseVars()

spliceLinksForNode = (node) ->
    toSplice = links.filter((l) -> l.source is node or l.target is node)
    toSplice.map((l) -> links.splice(links.indexOf(l), 1))

keydown = ->
    switch d3.event.keyCode
        when 71  # g
            showgrad.checked = not showgrad.checked
            reposition()
        when 70  # f
            showforce.checked = not showforce.checked
            reposition()
        when 78  # n
            move.checked = not move.checked
        when 66  # b
            showzero.checked = not showzero.checked
            reposition()
        when 8, 46  # backspace, delete
            if selected_node then selected_node.delete()
            else if selected_link then selected_link.delete()
            selected_link = selected_node = null
            redraw()
        else
            null
# init svg
outer = d3.select("#chart")
  .append("svg:svg")
    .attr("width", width)
    .attr("height", height)
    .attr("pointer-events", "all")
vis = outer
  .append('svg:g')
    .attr("transform", "translate(0,#{height}) scale(1,-1)")
  .append('svg:g')
    .call(zoomer)
    .on("dblclick.zoom", null)
  .append('svg:g')
    .on("mousemove", mousemove)
    .on("mousedown", mousedown)
    .on("mouseup", mouseup)
vis.append('svg:rect')
    .attr("x", -width/2)
    .attr("y", -height/2)
    .attr("width", width)
    .attr("height", height)
    .attr("fill", "transparent")
# init nodes,  links, and the line displayed when dragging new nodes
nodes = s.nodeList
links = s.beamList
node = vis.selectAll(".node")
link = vis.selectAll(".link")
force = vis.selectAll(".force")
grad = vis.selectAll(".grad")
drag_line = vis.append("line")
    .attr("class", "drag_line")
    .attr("x1", 0).attr("x2", 0)
    .attr("y1", 0).attr("y2", 0)
# add keyboard callback
d3.select(window).on("keydown", keydown)

prevobj = 0
reposition = ->
    s.solveSizing()
    #print [2 - s.beamList[0].L*s.beamList[1].L/s.nodeList[1].y/s.nodeList[1].y, s.nodeList[1].grad.y]
    drag_line.attr("stroke-width", 10/scale)
             .attr("stroke-dasharray", 10/scale+","+10/scale)
    link.attr("x1", (d) -> d.source.x).attr("x2", (d) -> d.target.x)
        .attr("y1", (d) -> d.source.y).attr("y2", (d) -> d.target.y)
        .attr("stroke-dasharray", (d) -> if d.diameter then null else 10/scale+","+10/scale)
        .classed("compression", (d) -> d.f < 0 and d.diameter)
        .classed("tension", (d) -> d.f > 0 and d.diameter)
        .transition()
          .duration(750)
          .ease("elastic")
            .attr("stroke-width",  (d) -> 10/scale * (d.diameter or 0.5*showzero.checked))
    node.attr("cx", (d) -> d.x)
        .attr("cy", (d) -> d.y)
        .transition()
          .duration(750)
          .ease("elastic")
          .attr("r", (d) -> 18/scale * if d is selected_node then 2 else 1)
    force.attr("stroke-width", (d) -> if dist(f for d, f of d.force) > 50/scale then 10/scale*showforce.checked else 0)
         .attr("x1", (d) -> d.x).attr("x2", (d) -> d.x + d.force.x/4)
         .attr("y1", (d) -> d.y).attr("y2", (d) -> d.y + d.force.y/4)
    grad.attr("x1", (d) -> d.x).attr("x2", (d) -> d.x - 50/scale*d.grad.x*nodes.length/s.lp.obj)
        .attr("y1", (d) -> d.y).attr("y2", (d) -> d.y - 50/scale*d.grad.y*nodes.length/s.lp.obj)
        .attr("stroke-width", (d) -> if 50/scale*dist(l for d, l of d.grad)*nodes.length/s.lp.obj > 0.05 then 10/scale*showgrad.checked else 0)
repositionfast = ->
    s.solveSizing()
    drag_line.attr("stroke-width", 10/scale)
           .attr("stroke-dasharray", 10/scale+","+10/scale)
    link.attr("x1", (d) -> d.source.x).attr("x2", (d) -> d.target.x)
      .attr("y1", (d) -> d.source.y).attr("y2", (d) -> d.target.y)
      .attr("stroke-dasharray", (d) -> if d.diameter then null else 10/scale+","+10/scale)
      .classed("compression", (d) -> d.f < 0 and d.diameter)
      .classed("tension", (d) -> d.f > 0 and d.diameter)
      .attr("stroke-width",  (d) -> 10/scale * (d.diameter or 0.5*showzero.checked))
    node.attr("cx", (d) -> d.x)
      .attr("cy", (d) -> d.y)
      .attr("r", (d) -> 18/scale * if d is selected_node then 2 else 1)
    force.attr("stroke-width", (d) -> if dist(f for d, f of d.force) > 50/scale then 10/scale*showforce.checked else 0)
         .attr("x1", (d) -> d.x).attr("x2", (d) -> d.x + d.force.x/4)
         .attr("y1", (d) -> d.y).attr("y2", (d) -> d.y + d.force.y/4)
    grad.attr("x1", (d) -> d.x).attr("x2", (d) -> d.x - 50/scale*d.grad.x*nodes.length/s.lp.obj)
        .attr("y1", (d) -> d.y).attr("y2", (d) -> d.y - 50/scale*d.grad.y*nodes.length/s.lp.obj)
        .attr("stroke-width", (d) -> if 50/scale*dist(l for d, l of d.grad)*nodes.length/s.lp.obj > 0.05 then 10/scale*showgrad.checked else 0)
repositionzoom = ->
    link.attr("stroke-dasharray", (d) -> if d.diameter then null else 10/scale+","+10/scale)
        .attr("stroke-width",  (d) -> 10/scale * (d.diameter or 0.5*showzero.checked))
    node.attr("r", (d) -> 18/scale * if d is selected_node then 2 else 1)
    force.attr("stroke-width", (d) -> if dist(f for d, f of d.force) > 50/scale then 10/scale*showforce.checked else 0)
    grad.attr("stroke-width", (d) -> if 50/scale*dist(l for d, l of d.grad)*nodes.length/s.lp.obj > 0.05 then 10/scale*showgrad.checked else 0)
@reposition = reposition
@repositionfast = repositionfast
@repositionzoom = repositionzoom

# set inital window
mins = {}
maxs = {}
means = {}
for d in ["x", "y", "z"]
    list = (n[d] for n in nodes)
    mins[d] = Math.min(list...)
    maxs[d] = Math.max(list...)
    means[d] = sum(list)/nodes.length
scale = 0.5*Math.min(width/(maxs.x-mins.x), height/(maxs.y-mins.y))
translate = [scale*means.x, height/2 - scale*means.y]
zoomer.scale(scale)
zoomer.translate(translate)
vis.attr("transform",
         "translate(#{translate}) scale(#{scale})")

redraw()
setTimeout((->
    s.nodeList[1].move({y: -0.5})
    reposition()), 500)

connectAllNodes = ->
    for ns in nodes
        connected_ids = (b.target.id for b in ns.sourced).concat(b.source.id for b in ns.targeted)
        for nt in s.nodeList when nt.id isnt ns.id
            if connected_ids.indexOf(nt.id) is -1 then new s.Beam(ns.id, nt.id)
    redraw()
@connectAllNodes = connectAllNodes

deleteAllBeams = ->
    while links.length
        links[0].delete()
    redraw()
@deleteAllBeams = deleteAllBeams


`
function redraw() {
  link = link.data(links);
  link.enter().insert("line", ".node")
      .attr("class", "link")
      .on("mousedown",
        function(d) {
          mousedown_link = d;
          if (mousedown_link == selected_link) selected_link = null;
          else selected_link = mousedown_link;
          selected_node = null;
          redraw();
        })
  link.exit().remove();
  link.classed("link_selected", function(d) { return d === selected_link; });

  force = force.data(nodes);
  force.enter().insert("line")
      .attr("class", "force")
      .attr("stroke-width", 0)
      .attr("marker-end", "url(#brtriangle)");
  force.exit().remove();

  grad = grad.data(nodes);
  grad.enter().insert("line")
      .attr("class","grad")
      .attr("stroke-width", 0)
      .attr("marker-end", "url(#ptriangle)");
  grad.exit().remove();

  node =  node.data(nodes);
  node.enter().insert("circle")
      .attr("class", "node")
      .attr("r", 5/scale)
      .on("mousedown",
        function(d) {
          // disable zoom
          vis.call(d3.behavior.zoom().on("zoom"), null);
          mousedown_node = d;
          if (mousedown_node == selected_node) selected_node = null;
          else selected_node = mousedown_node;
          selected_link = null;

          // reposition drag line
          drag_line
              .attr("class", "link")
              .attr("x1", mousedown_node.x)
              .attr("y1", mousedown_node.y)
              .attr("x2", mousedown_node.x)
              .attr("y2", mousedown_node.y);

          redraw();
        })
      .on("mousedrag",
        function(d) {
          // redraw();
        })
      .on("mouseup",
        function(d) {
          if (mousedown_node) {
            mouseup_node = d;
            if (mouseup_node == mousedown_node) { resetMouseVars(); return; }
            // add link
            beam_ = new s.Beam(mousedown_node.id, mouseup_node.id)
            // select new link
            selected_link = null;
            selected_node = mouseup_node;
            // enable zoom
            vis.call(d3.behavior.zoom().on("zoom"), rescale);
            redraw();
          }
        })
    .transition()
      .duration(750)
      .ease("elastic")
      .attr("r", 9/scale);

  node.exit().transition()
      .attr("r", 0)
    .remove();

  node.classed("node_selected", function(d) { return d === selected_node; });

  if (d3.event) d3.event.preventDefault();

  reposition();
}
`
@redraw = redraw



</script>


</head>
<body>
<div id="title"> tacit </div>
<div id="controls">
    <button onclick="deleteAllBeams();"><strong>Delete all beams</strong></button> <br>
    <button onclick="connectAllNodes();"><strong>Connect all nodes</strong></button> <br>
    <strong> show (f)orces</strong>
        <input type="checkbox" id="force" checked><br>
        <strong> show (g)radients</strong>
            <input type="checkbox" id="grad" checked><br>
    <strong> show unused (b)eams</strong>
        <input type="checkbox" id="showzero" checked onclick="reposition();"><br>
    <strong> allow moving (n)odes</strong>
        <input type="checkbox" id="move" checked><br>
    Scroll / pinch to zoom<br>
    Drag the background to pan</div>
  <div id="chart"></div>
<svg xmlns="http://www.w3.org/2000/svg" width="0" height="0">
  <marker id="brtriangle" viewBox="0 0 10 10" refX="1" refY="5" markerUnits="strokeWidth" markerWidth="4" markerHeight="3" orient="auto" fill="#3d3130">
      <path d="M 0 0 L 10 5 L 0 10 z"/>
  </marker>
  <marker id="ptriangle" viewBox="0 0 10 10" refX="1" refY="5" markerUnits="strokeWidth" markerWidth="4" markerHeight="3" orient="auto" fill="#807ec7">
      <path d="M 0 0 L 10 5 L 0 10 z"/>
  </marker>
</svg>
</body>
